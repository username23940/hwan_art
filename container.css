    /* flex, grid는 언제 쓰는가? 
    flex : 한줄 정렬 최적화(가로, 세로 한 방향으로). 아이템 크기가 유동적일 떄 자동 정렬하기 좋음
    grid : 2차원 레이아웃 최적화(행, 열 구조 필요시). 큰 레이아웃을 잡을 때, 공간 분할에 강함.(페이지, 섹션의 틀)
    보통 바깥쪽 큰 레이아웃 : grid. 안쪽 세부 정렬 : flex 
    */
    /* position의 relative와 absolute 속성값. relative는 요소를 원래 자리에서 상대적으로 이동. 부모나 다른 요소에 영향 없이
      자신의 위침나 이동. 이동 안하면 원래 자리 그대로. 다른 요소들은 relative가 원래 자리 차지한다고 생각해서 문서 흐름 깨지 X
      absolute는 요소를 문서 흐름에서 제거, 가장 가까운 position 중 relative, absolute, fixed인 부모를 기준으로(기준점) 그 안에서 배치. */
    /* align 관련 css 속성 
    text-align : 인라인 요소 텍스트(블록 요소 자체는 영향 X, 내부 콘텐츠만 정렬)
    align-tiems : flex, grid container 안의 자식들을 정렬.
    align-self : flex, grid container 내부의 아이템. align-items를 덮어쓰고 특정 아이템만 개별 정렬.
    justify-content  flex, grid container 안의 자식들을 정렬 
    place-items : grid container에서 align-items와 justify-items를 동시에 */
    /*  
    @media(max-width : 768px) {  모바일 화면 디자인  
      body{
        padding-top : 274.875px ;
      }
      .container-wrapper{
        flex-direction : column ;
        align-items : center ;
        gap: 10px ;
        margin : 0;
      }
      .container-wrapper ul {
        flex-direction : column ;
        padding-left: 0px ;
        gap : 10px ;
      }
    }
    */
    /* 따라서 모든 href와 src는 무조건 " (큰따옴표)로 통일하는 걸 추천해. 이러면 꼬일 확률이 거의 0이야. 그런데도 문제가 생긴다?
    절대 그럴 일 없음. 태그 닫힘, 주석 확인 필!! (F12로 a 태그 직접 확인해보기. 에디터에서 href="..." 따옴표가 진짜 ASCII " (0x22)인지 확인.) */


    .bodyhome { /* 전체 중앙정렬 */
      margin : 0 ;
      padding-bottom : 200px ;
      padding-top : 207.875px ;   /* fixed 유지하고, container에 flex를 제외 just 박스로 쓰고 wrapper 그대로, body에 패딩을 부여하고 h2를 패딩 이후로 작성하게 함 
      OR container 추가하며 fixed를 sticky로 레이아웃 흐름에 포함. 패딩 필요 없음 */
    }


    .container-wrapper { /* 로고와 메뉴 사이 가로 정렬. index 페이지에는 없는 sidebar로 인해 wrapper 사용. 다른 페이지에도 navbar가 들어갈 때 wrapper가 들어가니, 여기도 어쩔 수 없이 추가 */  
      display: flex; /* flex 컨테이너가 됨. 자식은 flex 아이템. 기본적으로 가로 방향 배치 */ 
      align-items: center;
      justify-content: center ; /* spacebetween 하면 시작은 왼쪽, 끝은 오른쪽. 사이는 균등배분. 
      그래서 이때는 gap 필요 없음(어차피 양끝으로 밀고 가운데가 전부 간격) -> 해보니까 강제로 양끝으로 가서 
      확대축소시 안예쁨.         
      
      또한 양끝으로 가서 좌우 패딩을 주면, 패딩은 컨테이너 안쪽 공간이기 때문에 실제 flex 공간이
      줄어들어, 이 줄어든 영역안에서 중앙에 오기 때문에 살짝 오른쪽으로 치우친 느낌 
      
      space around, evenly는 각각 아이템 사이 간격이 같고 양끝 간격은 그 절반 & 아이템 사이와 양끝간격 동일 */
    
      padding-top : 100px ; /* 위에서 조금 띄우기. padding 사용 시 배경색이 패딩까지 적용. 마진은 절대 적용 X.. BUT 스크롤 고려시 padding이 나음 */
      /* gap : 20px로고와 메뉴 사이 간격. 고정된 gap OR
      gap: 2vw (화면 너비의 2%)  OR  gap :  clamp(20px, 2vw, 100px). 유연하게 변하는 gap
      (margin과 달리 아이템 사이에만 간격 주고, 바깥쪽에는 안줌 */
      gap : 20% ;
      
      background: white ;  /* 이게 있어야 스크롤 했을 때 고정 느낌 남. 가려지니까 뒤에가  */
      position: fixed; /* fixed : 스크롤 해도 상단 고정(고정 메뉴바 느낌). 없으면 스크롤 할 때 컨테이너도 위로 사라짐 
        그러나 그 요소를 레이아웃 흐름에서 제거하므로, 밑의 요소들이 logo를 인식하지 못하고 겹치기 때문에, 높이만큼
        body에 컨테이너 크기만큼 패딩부여 필요
        sticky는 부모 흐름을 유지하면서 스크롤 시 유지 X (fixed 일 경우 container안에서 container-wrapper는 빠지니까 요소 1개로 인식) */ 
      top :0 ; left:0; /* fixed일 때 시작 좌표를 고정하지 않으면 레이아웃 흐름으로 인식함. sticky는 필요 없음 */
      width : 100%; /* 부모 기준 가로 전체를 채우겠다는 뜻. 50%면 가로 전체의 왼쪽 절반을 채움(왼쪽 부분 잘림). 
      fixed가 들어가면 레이아웃 흐름에서 제거되므로 자동으로 부모 너비를 채우지 않아 꼭 지정해야함(안그러면 0,0에 붙음) */
    }


    .container-wrapper .navbar {
      border : 1px solid transparent ; 
      letter-spacing : 8px ; /* 자간 */
    }
    .index-logo .container-wrapper .navbar .logo-first { /* 페이지별 로고 색상. OR js로 url 기준으로 현재 경로를 가져와 색상 적용 가능. 근데
     js가 script 태그로 html 위쪽에 있으면, DOM이 아직 로드되지 않아 document.querySelector('.logo-first')가 null 일수도. error. 그럴 땐 DOMContentLoaded 사용(
     (DOM이 완전히 로드된 후 JS 실행되도록) */
     /* class=bodyhome index일 때, .bodyhome .index로 적으면 안됨. .a .b라는 뜻 자체가 클래스 a를 가진 요소 안에(후손으로) 클래스 b를 가진 요소가 있어야 동작 
     .a.b는 어떤 요소가 두 클래스를 모두 가지고 있어야 적용. .a > .b는 a의 직계 자식 중 b를 가진 요소 */
      color : #9E2A2A ;
    }
    .container-wrapper .navbar .logo-second {
      color : black ;
    } 
    
      
    .container .menu  { /* menu class 안의 직계 a는 press. press만 선택. 드롭다운은 보통 > 직계자식선택자가 안전(후손 선택자, 공백 쓰면 중첩 서브메뉴까지 선택될 수도 */
      position : relative ;
    }
    .container .menu > a {
        font-size : large ;
    }
    .container .submenu {
      display : none ; /* 안쓰면 항상 떠있음. hover 시에만 보이려면 기본값이 숨겨져있어야 */
      position : absolute ; /* 하위 메뉴는 부모메뉴 바로 아래 떨어지므로, 부모인 nav li에 relative로 기준점 지정. absolute로 상대적 위치 선정 */
      top : 100% ;
      left : 0 ;
      padding : 0 ; margin : 0 ; /* submenu의 좌우 기본 padding, margin 제거 */
      padding-right : 40px ; /* submenu 미관상 우측 여백 필요 */
      font-size : small ;
    }
    .container .menu:hover .submenu { /* container class 안의 menu class에 마우스를 올렸을 때(:hover) menu안의 submenu만 선택 */
      display : block ; /* 원래 숨겨진 submenu를 조건부 선택자 :hover와 연결해 보이게 함 */
    }
    .container .menu .submenu a:hover {
      color : black ;
      font-weight : bold ;
    }
    

    ul {
      list-style : none ; /* 불릿 제거(점, 숫자, 로마숫자 등), disc, deciamal, lower-roman */
      display : flex ;
      align-items : center ;
      justify-content : center ;  
      gap : 15% ; /* li 끼리의 간격. 없으면 간격 안띄워짐 */
      padding-right : 40px ; /* browser 기본값으로 padding-left 40px 라 대칭 */
    }
    a {
      text-decoration-line : none ;  /* 링크들의 밑줄 제거. li 태그에 쓰면 안되고, 실제 밑줄이 있는 요소에 적용해야 함 */
    }


    img {
     width : 80% ;
     max-width : 800px ;
     display : block ; 
     margin : 0 auto ; /* block으로 바꾸고 좌우 자동 설정. OR img는 인라인 요소라서 부모에 text-align : center ; */
     margin-bottom : 10px ;
    }
    .caption { /* index 페이지를 제외한 페이지와 달리 img-wrapper에 싸여있지 않으므로 별도 생성 */
      font-size : small ; 
      text-align : center ;
    }
    #index-hr {
      border : none ;
      border-top : 10px solid #9E2A2A ; 
      width : 80% ;
      max-width : 1100px ; 
      margin-top : 60px ; /* border 자체가 padding을 덮는 box이므로 margin 써야함 */
      margin-left : auto ;
      margin-right : auto ;
      margin-bottom : 0 ;
    }
